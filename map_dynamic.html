<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Premium Retail Trainer Map</title>

<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
<link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />

<style>
  :root{
    --blue:#2f71ff; --violet:#6a1b9a; --gray:#9ea3a8; --ring:#d0d7de;
    --pa:#6c5ce7; --p:#2ecc71; --a:#f39c12; --u:#e74c3c;
    --bg:#fff; --fg:#111; --muted:#6b7280; --border:#e5e7eb; --panel:#fff;
  }
  html,body{height:100%;margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;background:var(--bg);color:var(--fg)}
  body{display:flex;flex-direction:column;min-width:320px}

  .topbar{position:sticky; top:0; background:var(--panel); display:flex;flex-wrap:wrap;gap:10px;align-items:center; padding:8px 10px;border-bottom:1px solid #eef0f3;z-index:10; box-shadow:0 4px 14px rgba(0,0,0,.04)}
  .search-wrap{display:flex;gap:8px;align-items:center;min-width:280px;flex:1}

  /* SEARCH: input never hides under the badge */
  .searchbox{position:relative;flex:1}
  .searchbox input{
    width:100%;border:1px solid #d0d7de;border-radius:10px;
    padding:10px 12px 10px 18px; /* default */
    font-size:14px;background:var(--bg);color:var(--fg)
  }
  .badge-left{
    position:absolute;left:8px;top:50%;transform:translateY(-50%);
    font-size:12px;font-weight:800;letter-spacing:.3px;background:#eef6ff;color:#0b5bd3;
    border:1px solid #cfe6ff;border-radius:999px;padding:3px 8px;display:none;pointer-events:none
  }
  .badge-left.show{display:inline-block}
  .searchbox.has-badge input{ padding-left:72px; } /* expands only when badge shown */

  .results{position:absolute;left:0;right:0;top:calc(100% + 6px);background:var(--panel);border:1px solid var(--border);border-radius:10px;box-shadow:0 10px 24px rgba(0,0,0,.18);display:none;z-index:20;max-height:360px;overflow:auto}
  .results.show{display:block}
  .res{display:flex;gap:10px;padding:10px;cursor:pointer;align-items:flex-start}
  .res:hover{background:#f6f8fa}
  #searchResults .res.active{ background:#e7f0ff }
  .res .kind{flex:0 0 auto;font-size:11px;font-weight:800;padding:4px 8px;border-radius:999px;border:1px solid var(--border);color:#374151;background:var(--panel)}
  .res .text .sub{color:var(--muted);font-size:12px;margin-top:2px;white-space:nowrap;overflow:hidden;text-overflow:ellipsis}

  .btn{border:1px solid #d0d7de;background:var(--panel);border-radius:10px;padding:8px 10px;font-weight:600;cursor:pointer;color:var(--fg); box-shadow:0 2px 8px rgba(0,0,0,.04)}
  .btn.link{border-color:transparent;text-decoration:underline}
  .toggle{display:inline-flex;align-items:center;gap:8px;border:1px solid var(--border);border-radius:999px;padding:6px 10px;background:var(--panel);white-space:nowrap}
  .toggle input{width:16px;height:16px;accent-color:var(--blue)}
  .range{display:flex;align-items:center;gap:8px;white-space:nowrap}
  .range small{color:var(--muted)}

  .pillbar{display:flex;gap:6px;flex-wrap:wrap;padding:6px 10px}
  .pill{display:inline-flex;align-items:center;gap:8px;border:1px solid #d0d7de;border-radius:999px;padding:6px 10px;background:var(--panel);color:var(--fg);cursor:pointer; box-shadow:0 2px 8px rgba(0,0,0,.04)}
  .pill .dot{width:10px;height:10px;border-radius:50%}

  .filters{display:grid;grid-template-columns:repeat(4,minmax(220px,1fr));gap:10px;padding:8px 10px;border-top:1px solid #eef0f3;border-bottom:1px solid #eef0f3;background:var(--panel); border-radius:12px; margin:6px 10px; box-shadow:0 6px 20px rgba(0,0,0,.06)}
  .picker{display:flex;flex-direction:column;gap:6px}
  .picker input{padding:6px 8px;font-size:13px;border:1px solid #d0d7de;border-radius:8px;background:var(--bg);color:var(--fg)}
  select[multiple]{height:110px;border:1px solid #d0d7de;border-radius:8px;padding:6px 8px;background:var(--bg);color:var(--fg)}

  .summary{display:flex;gap:10px;align-items:center;padding:6px 10px;border-bottom:1px solid #eef0f3;background:var(--panel)}
  .chip{display:inline-flex;align-items:center;gap:8px;padding:4px 10px;border:1px solid var(--border);border-radius:999px;background:var(--panel);}

  .dot{width:10px;height:10px;border-radius:50%}
  .muted{color:var(--muted);margin-left:auto}

  .mapwrap{position:relative;flex:1;min-height:460px;display:flex;overflow:hidden}
  #map{flex:1}

  .sidepanel{width:380px;max-width:90vw;flex:0 0 380px;background:var(--panel);border-left:1px solid var(--border);box-shadow:-4px 0 18px rgba(0,0,0,.12);display:none;flex-direction:column;z-index:6}
  .sidepanel.show{display:flex}
  .sp-head{padding:10px;border-bottom:1px solid var(--border);display:flex;align-items:center;gap:8px}
  .sp-head h3{margin:0;font-size:16px;line-height:1.2;flex:1}
  .sp-body{padding:10px;display:flex;flex-direction:column;gap:10px;height:calc(100vh - 220px);overflow:hidden}
  .sp-actions{display:flex;gap:8px;flex-wrap:wrap}
  .sp-counts{display:flex;gap:8px;flex-wrap:wrap}
  .sp-chip{display:inline-flex;align-items:center;gap:6px;border:1px solid var(--border);border-radius:999px;padding:3px 8px}
  .sp-quick{display:flex;gap:6px;flex-wrap:wrap}
  .sp-list{flex:1;min-height:160px;border:1px solid var(--border);border-radius:8px;padding:0;display:flex;flex-direction:column;overflow:auto; box-shadow: inset 0 0 0 2px rgba(0,0,0,.02)}
  .sp-list input{margin:8px;border:1px solid var(--border);border-radius:8px;padding:6px 8px}
  .sp-list input{position: sticky; top: 0; z-index: 3; background: var(--panel); border-bottom-left-radius: 0; border-bottom-right-radius: 0; box-shadow: 0 4px 6px rgba(0,0,0,.04);}

  .sp-rows{position:static;height:auto}
  .row{position:relative;display:flex;gap:8px;align-items:flex-start;padding:10px;border-bottom:1px solid var(--border);background:var(--panel);cursor:pointer;min-height:56px}
  .row .title{font-weight:800;line-height:1.25}
  .row .addr{color:var(--muted);font-size:12px;line-height:1.25}
  .row .num{min-width:62px;font-variant-numeric:tabular-nums;color:var(--muted)}
  .row.active{background:#e7f0ff}

  .floating{position:absolute;left:10px;top:10px;z-index:402;display:flex;gap:8px;flex-wrap:wrap}
  .floating .btn,.floating .toggle{padding:6px 8px;font-size:12px}

  /* LEGEND card (bottom-left by default) */
  .legend{
    position:absolute; bottom:14px; left:14px;
    background:var(--panel); border:1px solid var(--border);
    border-radius:10px; padding:10px 12px; box-shadow:0 4px 14px rgba(0,0,0,.08);
    z-index:400; max-width:260px; font-size:12px;
  }
  .legend .dot{display:inline-block; width:12px; height:12px; border-radius:2px; margin-right:6px; border:1px solid rgba(0,0,0,.1);}
  .legend .hub{width:14px; height:14px; border-radius:50%; border:2px solid #333; background:#fff;}

  .sandbox{position:absolute;left:10px;bottom:10px;z-index:402;background:var(--panel);border:1px solid var(--border);border-radius:10px;padding:10px 12px;display:none}

  .dropdown-menu{position:absolute;right:0;top:calc(100% + 4px);background:var(--panel);border:1px solid var(--border);border-radius:8px;padding:6px;z-index:5;max-height:70vh;overflow:auto;box-sizing:border-box;display:none;min-width:240px}

  .busy{position:fixed;inset:0;background:rgba(255,255,255,.5);display:flex;align-items:center;justify-content:center;z-index:9999}
  .busy[hidden]{display:none}
  .spin{width:36px;height:36px;border-radius:50%;border:4px solid rgba(0,0,0,.15);border-top-color:var(--blue);animation:spin .8s linear infinite}
  @keyframes spin{to{transform:rotate(360deg)}}

  .marker-cluster.marker-pa div{background:var(--pa);border:2px solid #fff}
  .marker-cluster.marker-p  div{background:var(--p); border:2px solid #fff}
  .marker-cluster.marker-a  div{background:var(--a); border:2px solid #fff}
  .marker-cluster.marker-u  div{background:var(--u); border:2px solid #fff }

  .hub{width:20px;height:20px;border-radius:50%;border:2px solid #fff;box-shadow:0 0 0 1px rgba(0,0,0,.25)}
  .hub.confirmed{background:var(--violet)}
  .hub.pending{background:#9ea3a8}
  .hub.acosta{ background: var(--a); }
  .hl{width:22px;height:22px;border-radius:50%;border:2px solid #111;background:rgba(0,0,0,.05);box-shadow:0 0 0 1px rgba(0,0,0,.25)}

  .modal{position:fixed;inset:0;background:rgba(0,0,0,.35);display:none;align-items:center;justify-content:center;z-index:5000}
  .modal.show{display:flex}
  .card{background:#fff;border-radius:12px;max-width:900px;width:92vw;box-shadow:0 20px 50px rgba(0,0,0,.25);border:1px solid var(--border)}
  .card header{padding:12px 14px;border-bottom:1px solid var(--border);display:flex;align-items:center;gap:10px}
  .card header h3{margin:0;font-size:18px;flex:1}
  .card .body{padding:14px;display:grid;grid-template-columns:1fr 1fr;gap:14px}
  .kbd{display:inline-block;border:1px solid #cfd3d7;border-bottom-width:3px;border-radius:6px;padding:2px 6px;font-weight:700;background:#fff}

  .view-row{display:flex;align-items:center;gap:8px;justify-content:space-between;padding:4px 0}
  .view-thumb{flex:0 0 auto;border:1px solid var(--border);border-radius:6px;width:96px;height:64px;background:#f9fafb}
  .view-actions{display:flex;gap:6px;align-items:center}

  .empty-state{position:absolute;inset:0;display:flex;align-items:center;justify-content:center;z-index:401;pointer-events:none}
  .empty-card{pointer-events:auto;background:var(--panel);border:1px solid var(--border);border-radius:12px;box-shadow:0 12px 28px rgba(0,0,0,.12);padding:14px 16px;max-width:520px}
  .empty-card h4{margin:0 0 6px 0}
  .empty-actions{display:flex;gap:8px;margin-top:10px;flex-wrap:wrap}
  .empty-state[hidden]{display:none !important;}

  .compare-panel{position:absolute;left:10px;bottom:120px;z-index:402;background:var(--panel);border:1px solid var(--border);border-radius:10px;padding:10px 12px;display:none;min-width:280px;box-shadow:0 10px 24px rgba(0,0,0,.12)}
  .compare-panel.show{display:block}
  .compare-grid{display:grid;grid-template-columns:1fr auto;gap:6px;align-items:baseline}

  @media (max-width:720px){ .card .body{grid-template-columns:1fr;} }
  @media (max-width: 1100px){ .filters{grid-template-columns:repeat(2,minmax(220px,1fr));} }
  @media (max-width: 640px){ .filters{grid-template-columns:1fr;} }
</style>
</head>
<body>

<div class="topbar">
  <div class="search-wrap" title="Type a store #, city/state, or hub name. Tip: type ‘near’ for nearby stores.">
    <div class="searchbox">
      <span id="searchBadge" class="badge-left">SEARCH</span>
      <input id="searchBox" type="text" placeholder="Type a store #, city/state, hub name… (tip: 'near Dallas')" autocomplete="off" aria-label="Search store or city" />
      <div id="searchResults" class="results" role="listbox"></div>
    </div>
    <button id="searchClear" class="btn" type="button" title="Clear search">Clear</button>
  </div>

  <label class="toggle" title="Show Premium confirmed hubs"><input id="showConfirmed" type="checkbox" checked />Premium (confirmed)</label>
  <label class="toggle" title="Show Premium pending offers"><input id="showPending" type="checkbox" checked />Premium (pending)</label>
  <label class="toggle" title="Show Acosta trainers"><input id="showAcosta" type="checkbox" checked />Acosta</label>

  <div class="range" title="Hub radius used for coverage, lists, rings, overlap">
    <span>Radius</span>
    <input id="radius" type="range" min="25" max="150" step="5" value="75" />
    <b id="radiusLbl">75</b><small>mi</small>
  </div>

  <button id="fitBtn" class="btn" type="button" title="Fit map to filtered stores">Fit to Results</button>
  <button id="homeBtn" class="btn" type="button" title="Reset to starting view (keeps filters)">Home</button>
  <button id="resetBtn" class="btn" type="button" title="Reset all filters and view">Reset</button>

  <!-- Export -->
  <div class="dropdown" id="exportDrop" style="position:relative">
    <button class="btn" type="button" title="Download CSV of filtered stores or panel list">Export ▾</button>
    <div class="dropdown-menu">
      <button id="exportStores" class="btn" type="button" style="display:block;width:100%;margin:4px 0" title="Export all filtered stores on the map">
        Export filtered stores (CSV)
      </button>
      <label class="toggle" style="margin:6px 4px;display:flex"><input id="autoReset" type="checkbox" />Auto-reset after export/print</label>
    </div>
  </div>

  <!-- Saved Views -->
  <div class="dropdown" id="viewsDrop" style="position:relative">
    <button class="btn" type="button" title="Save or recall views">Views ▾</button>
    <div class="dropdown-menu" id="viewsMenu">
      <button id="viewSave" class="btn" type="button" style="display:block;width:100%">Save current view…</button>
      <div style="border-top:1px solid var(--border);margin:6px 0"></div>
      <div id="viewList" style="min-width:220px"></div>
    </div>
  </div>

  <!-- Analysis buttons -->
  <button id="gapBtn" class="btn" type="button" title="Find cities with uncovered clusters">Gap finder</button>
  <button id="rollupBtn" class="btn" type="button" title="Totals by RM/AM">Rollups</button>

  <button id="helpBtn" class="btn" type="button" title="Quick tips and shortcuts">Help</button>
</div>

<div class="pillbar" id="presetBar">
  <div id="snapBtn" class="pill" title="Copy a shareable URL">🔗 Save snapshot link</div>
</div>

<div class="pillbar" id="activeChips"></div>

<!-- Filters -->
<div class="filters" title="Use these to narrow stores; search also matches store # and city/state.">
  <div class="picker">
    <input id="covSearch" type="text" placeholder="Search coverage…" />
    <select id="covFilter" multiple>
      <option value="All" selected>All</option>
      <option>Premium + Acosta</option>
      <option>Premium Only</option>
      <option>Acosta Only</option>
      <option>Uncovered</option>
    </select>
  </div>
  <div class="picker">
    <input id="rmSearch" type="text" placeholder="Filter regional managers…" />
    <select id="rmFilter" multiple><option value="All" selected>All</option></select>
  </div>
  <div class="picker">
    <input id="amSearch" type="text" placeholder="Filter area managers…" />
    <select id="amFilter" multiple><option value="All" selected>All</option></select>
  </div>
  <div class="picker">
    <input id="hubSearch" type="text" placeholder="Filter hubs…" />
    <select id="hubFilter" multiple></select>
  </div>
</div>

<div id="dataStatus" style="padding:6px 10px;color:var(--fg);font-size:12px"></div>

<div class="summary" id="summary">
  <span class="chip"><span class="dot" style="background:var(--pa)"></span>P+A: <b id="k_pa">0</b></span>
  <span class="chip"><span class="dot" style="background:var(--p)"></"></span>Premium: <b id="k_p">0</b></span>
  <span class="chip"><span class="dot" style="background:var(--a)"></span>Acosta: <b id="k_a">0</b></span>
  <span class="chip"><span class="dot" style="background:var(--u)"></span>Uncov: <b id="k_u">0</b></span>
  <span class="chip">Total: <b id="k_total">0</b></span>
  <span class="chip">Hubs — <b id="k_h_conf">0</b> confirmed • <b id="k_h_offer">0</b> pending offer • <b id="k_h_prop">0</b> proposed</span>
  <span class="muted" id="inView">In view: 0</span>
</div>
<div class="summary" id="datasetBadge"></div>

<div class="mapwrap">
  <div id="map" role="region" aria-label="Coverage Map"></div>

  <div class="floating">
    <label class="toggle" title="Density of stores"><input id="tgHeat" type="checkbox" />Heatmap</label>
    <label class="toggle" title="Show hub radius circles"><input id="tgRings" type="checkbox" />Hub radii</label>
    <label class="toggle" title="Highlight stores covered by 2+ hubs"><input id="tgOverlap" type="checkbox" />Overlap</label>
    <label class="toggle" title="Pin hubs to compare coverage"><input id="tgCompare" type="checkbox" />Compare</label>
    <label class="toggle" title="Filter: only stores inside any visible hub radius"><input id="tgWithin" type="checkbox" />Within hubs</label>
    <label class="toggle" title="Turn clustering on/off (useful when zoomed in)"><input id="tgCluster" type="checkbox" checked />Cluster</label>
    <button id="sandboxBtn" class="btn" type="button" title="Test a new hub location">New-hub sandbox</button>
  </div>

  <!-- Compare/Venn panel -->
  <div id="comparePanel" class="compare-panel">
    <div style="font-weight:800;margin-bottom:6px">Compare (2 pins)</div>
    <div id="compareBody" style="font-size:13px"></div>
    <div style="display:flex;gap:6px;margin-top:8px;flex-wrap:wrap">
      <button id="cmpExport" class="btn" type="button">Export CSV</button>
      <button id="cmpClear" class="btn" type="button">Clear pins</button>
    </div>
  </div>

  <div class="sidepanel" id="sidepanel">
    <div class="sp-head">
      <h3 id="spTitle">Hub</h3>
      <button id="spCollapse" class="btn" type="button" title="Collapse panel">⟨</button>
      <button id="spPinBtn" class="btn" type="button" title="Pin for compare">Pin</button>
      <button id="spLink" class="btn" type="button" title="Copy link to this hub">Link</button>
      <button id="spClose" class="btn" type="button" title="Close panel">Close</button>
    </div>
    <div class="sp-body">
      <div id="spMeta" class="sp-meta" style="font-size:13px"></div>
      <div class="sp-actions">
        <button id="spExport" class="btn" type="button" title="Download CSV of this list">Export list (CSV)</button>
        <button id="spPrint" class="btn" type="button" title="Print this list">Print store list</button>
      </div>
      <div class="sp-quick" title="Change hub radius quickly">
        Radius:
        <button class="btn" type="button" data-r="50">50</button>
        <button class="btn" type="button" data-r="75">75</button>
        <button class="btn" type="button" data-r="100">100</button><small> mi</small>
      </div>
      <div id="spCounts" class="sp-counts"></div>
      <div class="sp-list" id="spListWrap">
        <input id="spSearch" type="text" placeholder="Search stores in list…" />
        <div id="spRows" class="sp-rows"></div>
      </div>
    </div>
  </div>

  <!-- Empty state overlay -->
  <div id="emptyState" class="empty-state" hidden>
    <div class="empty-card">
      <h4>No stores match your filters</h4>
      <div class="muted">Try widening your radius, turning off “Within hubs”, or clearing a filter.</div>
      <div class="empty-actions">
        <button id="clearLastFilter" class="btn" type="button">Clear last filter</button>
        <button id="emptyReset" class="btn" type="button">Reset all</button>
      </div>
    </div>
  </div>
</div>
<!-- Help modal -->
<div class="modal" id="helpModal" aria-modal="true" role="dialog">
  <div class="card">
    <header>
      <h3>Help & Shortcuts</h3>
      <button id="helpClose" class="btn" type="button">Close</button>
    </header>
    <div class="body">
      <div>
        <h4>Keyboard</h4>
        <p><span class="kbd">Ctrl</span> / <span class="kbd">⌘</span> + <span class="kbd">K</span> — Focus search</p>
        <p><span class="kbd">↑</span> <span class="kbd">↓</span> + <span class="kbd">Enter</span> — Pick search result</p>
        <p><span class="kbd">H</span> — Home (map only)</p>
        <p><span class="kbd">F</span> — Focus side-panel search (when open)</p>
      </div>
      <div>
        <h4>Tips</h4>
        <ul>
          <li>Type <b>near</b> or <b>near Dallas</b> to jump the map and suggest nearby stores.</li>
          <li>Use <b>Within hubs</b> to see only stores covered by visible hubs.</li>
          <li>Pin hubs to compare coverage; <b>Overlap</b> highlights shared stores.</li>
          <li>Side panel shows counts & metrics; click a store to zoom to it.</li>
          <li>Use <b>Views</b> to save/restore your favorite setups.</li>
        </ul>
      </div>
    </div>
  </div>
</div>

<!-- Gap Finder modal -->
<div class="modal" id="gapModal" aria-modal="true" role="dialog">
  <div class="card">
    <header>
      <h3>Gap Finder</h3>
      <button id="gapClose" class="btn" type="button">Close</button>
    </header>
    <div class="body" style="grid-template-columns:1fr;">
      <div>
        <div style="display:flex;gap:8px;flex-wrap:wrap;margin-bottom:8px;align-items:center">
          <label class="toggle" title="Only show clusters at least this big">Min uncovered
            <input id="gapMin" type="number" value="10" style="width:80px;margin-left:8px">
          </label>
          <label class="toggle" title="Radius around each city center">Radius (mi)
            <input id="gapMiles" type="number" value="50" style="width:80px;margin-left:8px">
          </label>
          <button id="gapRun" class="btn" type="button">Run</button>
          <button id="gapExport" class="btn" type="button">Export CSV</button>
        </div>
        <div id="gapResults" style="max-height:65vh;overflow:auto"></div>
      </div>
    </div>
  </div>
</div>

<!-- Rollups modal -->
<div class="modal" id="rollupModal" aria-modal="true" role="dialog">
  <div class="card">
    <header>
      <h3>Manager rollups</h3>
      <button id="rollupClose" class="btn" type="button">Close</button>
    </header>
    <div class="body" style="grid-template-columns:1fr;">
      <div style="display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin-bottom:8px">
        <label class="toggle"><input type="radio" name="rollBy" id="rollByRM" checked> By Regional Manager</label>
        <label class="toggle"><input type="radio" name="rollBy" id="rollByAM"> By Area Manager</label>
        <button id="rollExport" class="btn" type="button">Export CSV</button>
      </div>
      <div id="rollTable" style="max-height:65vh;overflow:auto"></div>
    </div>
  </div>
</div>

<!-- Propose Hub modal -->
<div class="modal" id="submitModal" aria-modal="true" role="dialog">
  <div class="card">
    <header>
      <h3>Propose hub</h3>
      <button id="phClose" class="btn" type="button">Close</button>
    </header>
    <div class="body" style="grid-template-columns:1fr 1fr">
      <div>
        <label>City<br><input id="phCity" type="text" placeholder="e.g. Lakeland"></label>
      </div>
      <div>
        <label>State<br><input id="phState" type="text" placeholder="FL"></label>
      </div>
      <div>
        <label>Trainer / Candidate (optional)<br><input id="phName" type="text" placeholder="Name"></label>
      </div>
      <div>
        <label>Status<br>
          <select id="phStatus">
            <option>Proposed</option>
            <option>Pending Offer</option>
          </select>
        </label>
      </div>
      <div style="grid-column:1 / -1">
        <label>Notes (optional)<br><input id="phNotes" type="text" placeholder="context for this hub"></label>
      </div>
      <div style="grid-column:1 / -1;font-size:12px;color:var(--muted)">
        Lat/Lng and radius are pulled from the Sandbox ring.
      </div>
    </div>
    <div style="padding:12px 14px;border-top:1px solid var(--border);display:flex;gap:8px;justify-content:flex-end">
      <button id="phSubmit" class="btn" type="button">Save proposal</button>
    </div>
  </div>
</div>

<div id="busy" class="busy" hidden role="status" aria-live="polite" aria-label="Loading">
  <div class="spin"></div>
</div>

<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
<script src="https://unpkg.com/leaflet.heat@0.2.0/dist/leaflet-heat.js"></script>
<script>
(async function(){
  // ---------- CONFIG ----------
  const DATA_URL    = './store_data.json?v=' + Date.now();
  const ACOSTA_URL  = './acosta_geocoded.json?v=' + Date.now();
  const PREMIUM_URL = './premium_trainers_master.json?v=' + Date.now();

  const FALLBACK_STORES = [
    { storeNumberStr:"1234", storeName:"Walmart", address:"701 W 51st St", city:"Austin", state:"TX", coverageType:"Uncovered", areaManager:"", regionalManager:"", trainerCity:"", lat:30.309, lng:-97.742 },
    { storeNumberStr:"5678", storeName:"Walmart", address:"10 S Riverside", city:"Chicago", state:"IL", coverageType:"Uncovered", areaManager:"", regionalManager:"", trainerCity:"", lat:41.882, lng:-87.639 }
  ];

  const COLORS = {
    "Premium + Acosta": getCSS('--pa'),
    "Premium Only":     getCSS('--p'),
    "Acosta Only":      getCSS('--a'),
    "Uncovered":        getCSS('--u')
  };
  const DEFAULT_RADIUS = 75;
  const LS_STATE = 'prt_state_v9';
  const LS_VIEWS = 'prt_views_v2';
  const LS_LAST_QUERY = 'prt_last_query';
  const HOME_VIEW = { center:[39.5,-98.35], zoom:5 };
  const AUTO_RESET = ()=> id('autoReset')?.checked;

  const REV_KEY = 'prt_dataset_revs_v1';
  const USER_HUBS_KEY = 'prt_user_hubs_v1';
  const SUBMIT_URL = ''; // optional webhook; keep "" to skip

  let userHubs = [];
  let applyCustomToCoverage = false;

  // Hub sets
  let premiumConfirmed = [];
  let premiumPending   = [];
  let acostaHubs       = [];

  // Stores
  let allStores = [];
  let filteredStores = [];
  const markerByStore = new Map();

  let PENDING_OPEN_HUB_ID = null;
  let PENDING_PIN_IDS = [];

  // Map/layers
  const map = L.map('map', { zoomControl: true, inertia: true }).setView(HOME_VIEW.center, HOME_VIEW.zoom);
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 18, attribution: '© OpenStreetMap' }).addTo(map);
  const hubPane = map.createPane('hubPane'); hubPane.style.zIndex = 650; hubPane.style.pointerEvents = 'auto';

  const markers = L.markerClusterGroup({
    disableClusteringAtZoom: 12,
    spiderfyOnMaxZoom: false,
    maxClusterRadius: z => z >= 9 ? 50 : 70,
    iconCreateFunction: clusterIconByDominantCoverage,
    chunkedLoading: true,
    chunkInterval: 50,
    chunkDelay: 25
  });
  const plainMarkers = L.layerGroup();
  const targetLayer    = L.layerGroup().addTo(map);
  const ringLayer      = L.layerGroup().addTo(map);
  const highlightLayer = L.layerGroup().addTo(map);
  const hubLayer       = L.layerGroup().addTo(map);
  const heatLayerHolder = { layer: null };
  map.addLayer(markers);

  const mapwrapEl = document.querySelector('.mapwrap');

  // UI refs
  const STATUS = id('dataStatus'); const busy = id('busy');
  const showConfirmed = id('showConfirmed');
  const showPending   = id('showPending');
  const showAcosta    = id('showAcosta');
  const radius        = id('radius');  const radiusLbl = id('radiusLbl');
  const tgHeat = id('tgHeat'), tgRings=id('tgRings'), tgOverlap=id('tgOverlap'), tgCompare=id('tgCompare'), tgWithin=id('tgWithin'), tgCluster=id('tgCluster');
  const covFilter = id('covFilter'); const covSearch = id('covSearch');
  const rmFilter  = id('rmFilter');  const rmSearch  = id('rmSearch');
  const amFilter  = id('amFilter');  const amSearch  = id('amSearch');
  const hubFilter = id('hubFilter'); const hubSearch = id('hubSearch');
  const k = { pa:id('k_pa'), p:id('k_p'), a:id('k_a'), u:id('k_u'), total:id('k_total'),
             h_conf:id('k_h_conf'), h_offer:id('k_h_offer'), h_prop:id('k_h_prop'),
             inView:id('inView') };

  // Side panel refs
  const sidepanel = id('sidepanel');
  const spTitle = id('spTitle'); const spMeta = id('spMeta'); const spCounts = id('spCounts');
  const spRowsEl = id('spRows'); const spSearch = id('spSearch');
  const spLink = id('spLink');
  const spClose = id('spClose'); const spExport = id('spExport'); const spPinBtn = id('spPinBtn'); const spPrint = id('spPrint'); const spCollapse = id('spCollapse');
  let spHub = null; let spRows = []; let spFilter = '';

  // UX/analysis globals
  let compareMode = false;
  let pinnedHubs = [];
  let lastFilterChanged = null;
  const debouncedRun = (() => { let t; return () => { clearTimeout(t); t = setTimeout(runFilter, 90); }; })();
  const debouncedFitToResults = (() => { let t; return () => { clearTimeout(t); t = setTimeout(() => fitToResults(), 300); }; })();

  const getName = r => String(
    r.CandidateName ?? r.Candidate ?? r.RepName ?? r.repName ??
    r.TrainerName ?? r['Trainer Name'] ??
    r.Premium_Trainer ?? r.PremiumTrainer ??
    r.name ?? r.Name ?? ''
  ).trim();

  setTimeout(()=> map.invalidateSize(), 120);
<script>

// =========================
// PATCH A — Globals, Diagnostics, and Robust normalizeStores
// (Place ABOVE Chunk 4)
// =========================

// ---- Safe globals (only set if missing) ----
window.DEFAULT_RADIUS ??= 75;
window.HOME_VIEW ??= { center:[39.8283, -98.5795], zoom: 4 }; // CONUS
window.DATA_URL ??= 'store_data.json';       // adjust if you use a different filename
window.ACOSTA_URL ??= 'acosta_hubs.json';    // adjust if you use a different filename
window.PREMIUM_URL ??= 'premium_hubs.json';  // adjust if you use a different filename

// Layers/collections if not defined yet
window.allStores      ??= [];
window.premiumConfirmed ??= [];
window.premiumPending   ??= [];
window.acostaHubs       ??= [];
window.markerByStore    ??= new Map();

// If your UI doesn't already have a STATUS element:
window.STATUS = document.getElementById('STATUS') || { textContent:'', innerHTML:'', append(){}, };

// Fallback stores if nothing loads (tiny sample so you always see *something*)
window.FALLBACK_STORES ??= [
  { StoreID:'0001', StoreName:'Sample Store A', City:'Wichita', State:'KS', Zip:'67202', Latitude:37.686, Longitude:-97.335, RM:'Central', AM:'Wichita' },
  { StoreID:'0002', StoreName:'Sample Store B', City:'Dayton',  State:'OH', Zip:'45402', Latitude:39.7589, Longitude:-84.1916, RM:'East',    AM:'Dayton'  },
  { StoreID:'0003', StoreName:'Sample Store C', City:'Tampa',   State:'FL', Zip:'33602', Latitude:27.95,   Longitude:-82.4572, RM:'Southeast', AM:'Tampa' }
];

// ---- DIAGNOSTICS: pretty logger ----
function diag(label, obj){
  try { console.log(`LOAD DIAG — ${label}:`, obj); } catch(e){}
}

// ---- Super-robust normalizer for store files ----
// Accepts a wide variety of column names and shapes.
function normalizeStores(raw){
  if (!Array.isArray(raw)) return [];
  const out = [];
  for (const r of raw){
    // Accept either object rows or CSV-like arrays (skip arrays)
    if (r == null || typeof r !== 'object' || Array.isArray(r)) continue;

    // Extractors with many aliases
    const pick = (...keys)=> {
      for (const k of keys){
        if (r[k] != null && r[k] !== '') return r[k];
      }
      return undefined;
    };

    const idRaw = pick('StoreID','Store Id','Store_ID','Store_Number','Store #','store_id','id','Store');
    const name  = pick('StoreName','Store Name','name','Store_Name','Location','Walmart','Title');
    const city  = pick('City','city','StoreCity','Store City');
    const state = pick('State','state','St','Prov','Province');
    const zip   = pick('Zip','ZIP','Postal','PostalCode','ZipCode','zip','Postal Code','Zip Code');
    const lat   = Number(pick('Latitude','Lat','lat','Y','Lat_dd','latitude'));
    const lng   = Number(pick('Longitude','Lon','Lng','lon','X','Long_dd','longitude'));
    const rm    = pick('RM','RegionalManager','Regional Manager','Region Manager','Region','RM_Name','RMName');
    const am    = pick('AM','AreaManager','Area Manager','AM_Name','AMName','Territory','Territory Manager');

    // Skip if no coordinates
    if (!Number.isFinite(lat) || !Number.isFinite(lng)) continue;

    // Build a stable id if missing
    const id = (idRaw!=null && String(idRaw).trim() !== '')
      ? String(idRaw)
      : `${(name||'Store')}-${(city||'')}-${(state||'')}-${lat.toFixed(4)},${lng.toFixed(4)}`;

    out.push({
      id: String(id),
      store_name: name ?? 'Store',
      city: city ?? '',
      state: state ?? '',
      postal: zip ?? '',
      lat, lng,
      rm: rm ?? '',
      am: am ?? '',
      coverageType: 'Uncovered',
      coverage: { hubs: [] }
    });
  }

  // DIAGNOSTICS
  diag('normalizeStores.count', out.length);
  if (out.length){
    const keys = Object.keys(raw[0]||{});
    diag('normalizeStores.firstRowKeys', keys);
    diag('normalizeStores.sample', out.slice(0, 3));
  }
  return out;
}

// ---- Minimal stubs if missing (won’t override your real ones) ----
window.showBusy ??= (on)=>{ try{
  const el = document.getElementById('busy'); if (!el) return;
  el.style.display = on ? 'inline-flex' : 'none';
} catch(e){} };

window.mkStoreMarker ??= function(s){
  const mk = L.circleMarker([s.lat, s.lng], { radius:5, color:'#999', weight:1, fillOpacity:0.9 });
  mk._store = s;
  mk.bindPopup(`<b>${(s.store_name||'Store')}</b><br>${s.city||''}, ${s.state||''}`);
  return mk;
};

// Create map & layers if not already created by your earlier chunks
window.map ||= L.map('map', { preferCanvas:true }).setView(HOME_VIEW.center, HOME_VIEW.zoom);
if (!window._baseTileAdded){
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 18, attribution:'© OSM' }).addTo(map);
  window._baseTileAdded = true;
}
window.markers        ||= L.markerClusterGroup({ disableClusteringAtZoom: 11 }).addTo(map);
window.plainStoreLayer||= L.layerGroup();
window.hubLayer       ||= L.layerGroup().addTo(map);
window.ringLayer      ||= L.layerGroup().addTo(map);
window.highlightLayer ||= L.layerGroup().addTo(map);

// Useful helper expected elsewhere
function updateInViewCountSafe(){
  try{
    const group = document.getElementById('tgCluster')?.checked ? markers : plainStoreLayer;
    const n = group.getLayers().length;
    (document.getElementById('inViewCount')||{}).textContent = (n||0).toLocaleString();
  }catch(e){}
}
</script>
<script>
// =========================
// CHUNK 4 — Events & Data
// =========================

// Event wiring — visibility affects coverage
showConfirmed.onchange = handleHubVisibilityChange;
showPending.onchange   = handleHubVisibilityChange;
showAcosta.onchange    = handleHubVisibilityChange;

on('input', radius, ()=>{
  radiusLbl.textContent = radius.value;
  recomputeCoverage();
  debouncedRun();
  debouncedFitToResults();
  updateRings();
  buildHubFilterOptions();
  if (tgOverlap.checked) drawOverlap();
  if (sandboxMarker) refreshSandbox?.();
  if (spHub) openSidepanel(spHub);
  refreshComparePanel();
  saveState();
});

on('input', covSearch, ()=> filterSelect(covFilter, covSearch.value));
on('input', rmSearch,  ()=> filterSelect(rmFilter,  rmSearch.value));
on('input', amSearch,  ()=> filterSelect(amFilter,  amSearch.value));
on('input', hubSearch, ()=> filterSelect(hubFilter, hubSearch.value));

// Quick radius buttons
document.querySelectorAll('.sp-quick .btn[data-r]').forEach(b => {
  b.addEventListener('click', () => {
    radius.value = b.dataset.r;
    radiusLbl.textContent = b.dataset.r;
    recomputeCoverage(); runFilter(); updateRings();
    if (spHub) openSidepanel(spHub);
    refreshComparePanel(); saveState(); fitToResults();
  });
});

on('change', rmFilter,  ()=>{ lastFilterChanged='rmFilter'; cascadeAM(); runFilter(); fitToResults(); saveState(); renderChips(); buildHubFilterOptions(); });
rebuildAMOptionsWithCounts();
on('change', amFilter,  ()=>{ lastFilterChanged='amFilter'; runFilter(); fitToResults(); saveState(); renderChips(); buildHubFilterOptions(); });
on('change', covFilter, ()=>{ lastFilterChanged='covFilter'; runFilter(); fitToResults(); saveState(); renderChips(); buildHubFilterOptions(); });
on('change', hubFilter, ()=>{ lastFilterChanged='hubFilter'; runFilter(); fitToResults(); saveState(); renderChips(); });

id('fitBtn').onclick  = ()=>{ fitToResults(); saveState(); };
id('homeBtn').onclick = ()=>{ map.setView(HOME_VIEW.center, HOME_VIEW.zoom); };
id('resetBtn').onclick= ()=>{ resetAll(); runFilter(); saveState(); renderChips(); };

// Dropdowns & views
const exportDrop = id('exportDrop'); const menu = exportDrop.querySelector('.dropdown-menu');
exportDrop.querySelector('button').onclick = ()=> toggleDropdown(menu);
on('click', document.body, (e)=>{ if (!exportDrop.contains(e.target)) menu.style.display='none'; }, true);
id('exportStores').onclick  = ()=>{ exportStoresCsv(); if(AUTO_RESET()) { resetAll(); runFilter(); renderChips(); } };

const viewsDrop = id('viewsDrop'); const viewsMenu = id('viewsMenu'); const viewList = id('viewList');
viewsDrop.querySelector('button').onclick = ()=> toggleDropdown(viewsMenu);
on('click', document.body, (e)=>{ if (!viewsDrop.contains(e.target)) viewsMenu.style.display='none'; }, true);
id('viewSave').onclick = saveCurrentView;
rebuildViewsMenu();

// Floating toggles
tgHeat.onchange   = ()=>{ if (tgHeat.checked) updateHeat(); else clearHeat(); saveState(); };
tgRings.onchange  = ()=>{ updateRings(); saveState(); };
tgOverlap.onchange= ()=>{ if (tgOverlap.checked) drawOverlap(); else highlightLayer.clearLayers(); saveState(); };
tgCompare.onchange= ()=>{ compareMode = tgCompare.checked; pinnedHubs=[]; highlightLayer.clearLayers(); refreshComparePanel(); alert(compareMode ? 'Compare mode on: click hub markers to pin them.' : 'Compare mode off.'); saveState(); };
tgWithin.onchange = ()=>{ lastFilterChanged='tgWithin'; runFilter(); fitToResults(); saveState(); };
tgCluster.onchange= ()=>{ refreshLayerMode(); };

// Keyboard
const searchBox = id('searchBox'), searchBadge = id('searchBadge'), searchResults = id('searchResults');
const searchWrap = document.querySelector('.searchbox');
id('searchClear').onclick = ()=>{ searchBox.value=''; localStorage.removeItem(LS_LAST_QUERY); searchBadge.classList.remove('show'); searchWrap.classList.remove('has-badge'); hideResults(); clearTarget(); runFilter(); fitToResults(); };
window.addEventListener('keydown',(e)=>{
  if ((e.ctrlKey||e.metaKey) && e.key.toLowerCase()==='k'){ e.preventDefault(); searchBox.focus(); searchBox.select(); }
  if (e.key.toLowerCase() === 'h'){ map.setView(HOME_VIEW.center, HOME_VIEW.zoom); }
  if (e.key.toLowerCase() === 'f' && sidepanel.classList.contains('show')){ spSearch.focus(); spSearch.select(); }
});

// Side panel actions
spClose.onclick = ()=> hideSidepanel();
spCollapse.onclick = ()=> hideSidepanel();
spSearch.addEventListener('input', ()=>{ spFilter = spSearch.value.trim().toLowerCase(); renderSidepanelList(); });
spExport.onclick = ()=>{ exportSidepanelCsv(); if(AUTO_RESET()){ resetAll(); runFilter(); renderChips(); } };
spPrint.onclick  = ()=>{ printSidepanelList();  if(AUTO_RESET()){ resetAll(); runFilter(); renderChips(); } };
spPinBtn.onclick = ()=> togglePinFromPanel();

// Map events
markers.on('clustermouseover', (e)=>{
  const cts = coverageCounts(e.layer.getAllChildMarkers());
  const total = Object.values(cts).reduce((a,b)=>a+b,0)||1;
  const pct = k => Math.round((cts[k]||0)*100/total);
  const html = `
    <div style="font-size:12px">
      <div><b>${total}</b> stores</div>
      <div><span class="dot" style="background:${COLORS["Premium + Acosta"]}"></span> P+A: <b>${cts["Premium + Acosta"]||0}</b> (${pct("Premium + Acosta")}%)</div>
      <div><span class="dot" style="background:${COLORS["Premium Only"]}"></span> Premium: <b>${cts["Premium Only"]||0}</b> (${pct("Premium Only")}%)</div>
      <div><span class="dot" style="background:${COLORS["Acosta Only"]}"></span> Acosta: <b>${cts["Acosta Only"]||0}</b> (${pct("Acosta Only")}%)</div>
      <div><span class="dot" style="background:${COLORS["Uncovered"]}"></span> Uncovered: <b>${cts["Uncovered"]||0}</b> (${pct("Uncovered")}%)</div>
    </div>`;
  e.layer.bindTooltip(html, {direction:'top', offset:[0,-12], opacity:0.95, sticky:true}).openTooltip();
});
markers.on('clustermouseout', (e)=>{ e.layer.closeTooltip(); });
markers.on('clusterclick', (e)=>{ map.fitBounds(e.layer.getBounds()); });
map.on('moveend zoomend', ()=>{
  updateInViewCount();
  if (id('tgHeat').checked) requestIdleCallback?.(updateHeat) ?? updateHeat();
  saveState();
});

// ---------- Load data ----------
showBusy(true); let spinnerFailSafe = setTimeout(()=>showBusy(false), 7000);
try {
  // STORES
  STATUS.textContent = `Loading ${DATA_URL} …`;
  let storeRaw = null;
  try{
    const resp = await fetch(DATA_URL, { cache:'no-store' });
    if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
    const text = await resp.text();
    storeRaw = JSON.parse(text.replace(/^\uFEFF/,''));
    if (!Array.isArray(storeRaw)) throw new Error('store_data.json must be a JSON array');
  }catch(fetchErr){
    console.warn('Data fetch failed, using fallback stores:', fetchErr);
    STATUS.innerHTML = `<span style="color:#a15b00;font-weight:600">Loaded fallback test data</span> — place <code>store_data.json</code> next to this file to load real data.`;
    storeRaw = FALLBACK_STORES;
  }
  allStores = normalizeStores(storeRaw);
  STATUS.textContent += `  |  ${allStores.length.toLocaleString()} stores ready`;

  populateRM(allStores); populateAM(allStores);

  // ACOSTA
  try {
    const aResp = await fetch(ACOSTA_URL, { cache: 'no-store' });
    if (!aResp.ok) throw new Error(`HTTP ${aResp.status} for ${ACOSTA_URL}`);
    const aJson = await aResp.json();
    const rows = Array.isArray(aJson) ? aJson : [];
    acostaHubs = rows
      .map(r => ({
        lat: Number(r.Latitude ?? r.latitude ?? r.lat),
        lng: Number(r.Longitude ?? r.longitude ?? r.lng),
        name: String(r.RepName ?? r.name ?? 'Acosta Rep'),
        city: String(r.City ?? ''), state: String(r.State ?? '')
      }))
      .filter(r => Number.isFinite(r.lat) && Number.isFinite(r.lng))
      .map(r => ({
        id: 'ac_' + slug(`${r.name}-${r.city}-${r.state}`),
        name: r.name, fullName: `${r.name} — ${r.city}, ${r.state}`,
        coords: [r.lat, r.lng], status: 'acosta'
      }));
    STATUS.textContent += `  |  Acosta hubs: ${acostaHubs.length}`;
  } catch (e) {
    STATUS.innerHTML += `  |  <span style="color:#b42318">Acosta failed</span>`;
    console.error('Acosta load error:', e);
    acostaHubs = [];
  }

  // PREMIUM hubs
  try {
    const pResp = await fetch(PREMIUM_URL, { cache: 'no-store' });
    const pJson = await pResp.json();
    const rows = Array.isArray(pJson)
      ? pJson
      : [
          ...(pJson.confirmed || []),
          ...(pJson.pending  || []),
          ...(pJson.open     || []),
          ...(pJson.recruit  || []),
          ...(pJson.cities   || []),
        ];
    const txt = v => String(v ?? '').toLowerCase();
    const statusText = r => {
      const fields = [ r.Status, r.status, r.HubStatus, r.Hub_Status, r.TrainerStatus, r.Trainer_Status, r.CandidateStatus, r.AssignmentStatus ];
      return fields.map(txt).find(Boolean) || '';
    };
    const isOffer      = s => /(offer|accepted)/i.test(s);
    const isProposed   = s => /(propos|plan|target)/i.test(s);
    const isRecruiting = s => /(recruit|source|pipeline|tbd|open|no cand|no appl|no\s*applicants|search)/i.test(s);

    const getCity = r => String(
      r.City ?? r.city ?? r.Hub_City ?? r['Hub City'] ?? r.ProposedCity ?? r['Proposed City'] ??
      r.TargetCity ?? r['Target City'] ?? r.CandidateCity ?? r['Candidate City'] ?? r.HubCity ?? ''
    ).trim();
    const getState = r => String(
      r.State ?? r.state ?? r.Hub_State ?? r['Hub State'] ?? r.ProposedState ?? r['Proposed State'] ??
      r.TargetState ?? r['Target State'] ?? r.CandidateState ?? r['Candidate State'] ?? r.HubState ?? ''
    ).trim();
    const getCoords = r => {
      const lat = Number(r.Latitude  ?? r.latitude  ?? r.lat ?? r.Lat ?? r.lat_dd ?? r.Latitude__c);
      const lng = Number(r.Longitude ?? r.longitude ?? r.lng ?? r.Lon ?? r.lng_dd ?? r.Longitude__c);
      return (Number.isFinite(lat) && Number.isFinite(lng)) ? [lat, lng] : null;
    };
    const getName = r => String(
      r.TrainerName ?? r['Trainer Name'] ?? r.CandidateName ?? r['Candidate Name'] ?? r.Name ?? r.name ?? ''
    ).trim();

    function coordsFromCityState(city, state){
      if (!city || !state) return null;
      const rows = allStores.filter(s =>
        (s.city||'').toLowerCase() === city.toLowerCase() &&
        (s.state||'').toUpperCase() === state.toUpperCase()
      );
      if (rows.length){
        const lat = rows.reduce((a,b)=>a+b.lat,0)/rows.length;
        const lng = rows.reduce((a,b)=>a+b.lng,0)/rows.length;
        return [lat, lng];
      }
      return null;
    }

    const classify = r => {
      const s = statusText(r);
      const hasName = !!getName(r);
      if (hasName && !isOffer(s) && !isProposed(s) && !isRecruiting(s) && !/pend/i.test(s)) {
        return { status: 'confirmed', statusSub: 'confirmed' };
      }
      if (isOffer(s))      return { status: 'pending', statusSub: 'pending_offer' };
      if (isProposed(s))   return { status: 'pending', statusSub: 'proposed' };
      if (isRecruiting(s)) return { status: 'pending', statusSub: 'open' };
      return { status: 'pending', statusSub: hasName ? 'pending_candidate' : 'proposed' };
    };

    const pretty = sub => ({
      confirmed:'Confirmed', pending_offer:'Pending Offer', proposed:'Proposed',
      open:'Proposed', pending_candidate:'Proposed'
    }[sub] || 'Proposed');

    const toHub = (r) => {
      let coords = getCoords(r);
      let city   = getCity(r);
      let state  = getState(r);
      let nm     = getName(r);

      if (!coords && city && state) coords = coordsFromCityState(city, state);
      if (!coords) return null;
      let [lat, lng] = coords;

      const { status, statusSub } = classify(r);
      const statusLabel = pretty(statusSub);
      const trainerBit  = nm ? ` — ${nm}` : '';
      const place = city && state ? `${city}, ${state}` : (city || state || '');
      const label = `${place} (${statusLabel}${trainerBit})`;

      return {
        id: `${status[0]}_${slug(`${city||''}-${state||''}-${lat.toFixed(3)}-${lng.toFixed(3)}-${nm||''}`)}`,
        name: nm || 'Proposed',
        label, fullName: label,
        coords: [lat, lng],
        status, statusSub, statusLabel,
        city, state
      };
    };

    const STATUS_PRIORITY = { confirmed:5, pending_offer:4, pending_candidate:3, open:2, proposed:1 };
    function hubKey(h){
      if (h.city && h.state) return `${h.city.toLowerCase()}|${h.state.toLowerCase()}`;
      return `${h.coords[0].toFixed(3)},${h.coords[1].toFixed(3)}`;
    }
    function coalesceHubs(list){
      const byKey = new Map();
      for (const h of list){
        const key = hubKey(h);
        const cur = byKey.get(key);
        if (!cur) { byKey.set(key, h); continue; }
        const a = cur, b = h;
        const pa = STATUS_PRIORITY[a.statusSub] || 0;
        const pb = STATUS_PRIORITY[b.statusSub] || 0;
        const pick = (pb > pa || (pb === pa && !a.name && b.name)) ? b : a;
        byKey.set(key, pick);
      }
      return Array.from(byKey.values());
    }

    const hubs = rows.map(toHub).filter(Boolean);
    const merged = coalesceHubs(hubs);
    premiumConfirmed = merged.filter(h => h.status === 'confirmed');
    premiumPending   = merged.filter(h => h.status === 'pending');
  } catch (e) {
    console.warn('Premium file missing/invalid', e);
    premiumConfirmed = []; premiumPending = [];
  }

  // Load user proposals (local)
  loadUserHubs();

  // Build initial UI state
  buildSearchIndex();
  buildHubFilterOptions();

  // Attempt to restore a saved view; fallback to local defaults
  if (!tryLoadSnapshot()){ tryLoadLocal(); }

  // Compute coverage once all hubs are ready
  recomputeCoverage();
  renderHubs();
  refreshLayerMode();
  runFilter();
  fitToResults();
  updateRings();
  renderLegend();           // ensure legend appears once layers exist
  updateInViewCount();
  saveState();

  showBusy(false); clearTimeout(spinnerFailSafe);
} catch (fatalErr){
  console.error('Fatal init error:', fatalErr);
  STATUS.innerHTML += `  |  <span style="color:#b42318">Init failed</span>`;
  showBusy(false); clearTimeout(spinnerFailSafe);
}
</script>
<script>
// =========================
// CHUNK 5 — Render, Filter, Cascades, Sidepanel
// =========================

// ---------- Small helpers ----------
function getSelVals(selectEl){
  return Array.from(selectEl.selectedOptions).map(o => o.value).filter(v => v !== '');
}
function setOptions(selectEl, options, {placeholder='All', keepSelection=true}={}){
  const prev = new Set(getSelVals(selectEl));
  selectEl.innerHTML = '';
  const optAll = document.createElement('option');
  optAll.value = ''; optAll.textContent = placeholder;
  selectEl.appendChild(optAll);
  for (const {value,label,count} of options){
    const o = document.createElement('option');
    o.value = value; o.textContent = count!=null ? `${label} (${count})` : label;
    if (keepSelection && prev.has(value)) o.selected = true;
    selectEl.appendChild(o);
  }
}
function visibleHubs(){
  const showP  = showConfirmed.checked;
  const showPe = showPending.checked;
  const showA  = showAcosta.checked;
  const list = [];
  if (showP)  list.push(...(premiumConfirmed||[]));
  if (showPe) list.push(...(premiumPending||[]));
  if (showA)  list.push(...(acostaHubs||[]));
  return list;
}

// ---------- Cascading filters ----------
function rebuildAMOptionsWithCounts(){
  // Build AM list, optionally constrained by selected RM(s)
  const selRMs = new Set(getSelVals(rmFilter));
  const amCounts = new Map();
  for (const s of allStores){
    if (selRMs.size && !selRMs.has(String(s.rm))) continue;
    const key = String(s.am||'');
    amCounts.set(key, (amCounts.get(key)||0)+1);
  }
  const rows = Array.from(amCounts.entries())
    .filter(([k]) => k && k.trim().length)
    .sort((a,b)=> a[0].localeCompare(b[0]))
    .map(([value,count]) => ({ value, label:value, count }));
  setOptions(amFilter, rows, {placeholder:'All Area Managers'});
}

// When RM changes, restrict AMs and Hubs accordingly
function cascadeAM(){
  rebuildAMOptionsWithCounts();
  buildHubFilterOptions(); // Hubs depend on RM/AM + toggles
}

// ---------- Hub filter options (depends on toggles + RM/AM) ----------
function buildHubFilterOptions(){
  const selRMs = new Set(getSelVals(rmFilter));
  const selAMs = new Set(getSelVals(amFilter));
  const hubs = visibleHubs();

  // Count hubs by (name/city/state), applying RM/AM constraints if the hub is associated via stores
  // Association heuristic: include hub if at least one store it covers belongs to selected RM/AM (after current radius)
  const counts = new Map();
  for (const h of hubs){
    let include = true;
    if (selRMs.size || selAMs.size){
      include = false;
      // Look for any store currently attributed to this hub within the radius & filters
      for (const s of allStores){
        if (selRMs.size && !selRMs.has(String(s.rm))) continue;
        if (selAMs.size && !selAMs.has(String(s.am))) continue;
        if (!s.coverage || !s.coverage.hubs) continue;
        // coverage.hubs is assumed like [{id, type:'premium'|'acosta', dist}]
        if (s.coverage.hubs.some(x => x.id === h.id)) { include = true; break; }
      }
    }
    if (!include) continue;
    const key = h.id;
    counts.set(key, {h, n:(counts.get(key)?.n||0)+1});
  }

  const rows = Array.from(counts.values())
    .map(({h,n})=>{
      const label = h.fullName || h.label || h.name || `${h.city||''}, ${h.state||''}`.trim();
      return { value:h.id, label, count:n };
    })
    .sort((a,b)=> a.label.localeCompare(b.label));

  setOptions(hubFilter, rows, {placeholder:'All Hubs'});
}

// ---------- Coverage computation glue (stores ← hubs) ----------
function recomputeCoverage(){
  // Uses: allStores, premiumConfirmed, premiumPending, acostaHubs, radius
  // Writes: s.coverage.coverageType and s.coverage.hubs
  const r = Number(radius.value) || DEFAULT_RADIUS;

  // Prebuild a flat list of hubs with type tags for quick distance checks
  const hubList = [];
  if (showConfirmed.checked) hubList.push(...(premiumConfirmed||[]).map(h => ({...h, _type:'premium'})));
  if (showPending.checked)   hubList.push(...(premiumPending||[]).map(h   => ({...h, _type:'premium'})));
  if (showAcosta.checked)    hubList.push(...(acostaHubs||[]).map(h       => ({...h, _type:'acosta'})));

  for (const s of allStores){
    const near = [];
    for (const h of hubList){
      const d = distMiles(s.lat, s.lng, h.coords[0], h.coords[1]);
      if (d <= r) near.push({id:h.id, type:h._type, dist:d});
    }
    near.sort((a,b)=> a.dist - b.dist);
    s.coverage = { hubs: near };

    let hasPrem = near.some(x => x.type === 'premium');
    let hasAco  = near.some(x => x.type === 'acosta');

    let covType = 'Uncovered';
    if (hasPrem && hasAco) covType = 'Premium + Acosta';
    else if (hasPrem)      covType = 'Premium Only';
    else if (hasAco)       covType = 'Acosta Only';

    s.coverageType = covType;
  }
}

// ---------- Marker rendering ----------
function renderHubs(){
  hubLayer.clearLayers();
  ringLayer.clearLayers();

  const hubs = visibleHubs();
  for (const h of hubs){
    // Hub marker
    const m = mkHubMarker(h);
    m.on('click', ()=> openSidepanel(h));
    hubLayer.addLayer(m);

    // Ring
    if (tgRings.checked){
      const ring = L.circle(h.coords, {
        radius: (Number(radius.value)||DEFAULT_RADIUS) * 1609.34,
        color: h.status === 'acosta' ? '#555' : '#2f71ff',
        weight: 1, fillOpacity: 0.05
      });
      ringLayer.addLayer(ring);
    }
  }
}

// ---------- Filtering stores + layer mode ----------
function storePassesFilters(s){
  // Coverage filter
  const selCov = new Set(getSelVals(covFilter));
  if (selCov.size && !selCov.has(s.coverageType)) return false;

  // RM / AM filter
  const selRMs = new Set(getSelVals(rmFilter));
  const selAMs = new Set(getSelVals(amFilter));
  if (selRMs.size && !selRMs.has(String(s.rm))) return false;
  if (selAMs.size && !selAMs.has(String(s.am))) return false;

  // Hub filter
  const selHubs = new Set(getSelVals(hubFilter));
  if (selHubs.size){
    const ids = (s.coverage?.hubs||[]).map(x => x.id);
    if (!ids.some(id => selHubs.has(id))) return false;
  }

  // Within toggle handled implicitly by recomputeCoverage() + hub selection
  if (tgWithin.checked && !(s.coverage?.hubs?.length)) return false;

  return true;
}

function refreshLayerMode(){
  // switch between cluster and single layer
  if (tgCluster.checked){
    if (map.hasLayer(plainStoreLayer)) map.removeLayer(plainStoreLayer);
    if (!map.hasLayer(markers)) map.addLayer(markers);
  } else {
    if (map.hasLayer(markers)) map.removeLayer(markers);
    if (!map.hasLayer(plainStoreLayer)) map.addLayer(plainStoreLayer);
  }
}

function runFilter(){
  markerByStore.clear();
  if (tgCluster.checked){ markers.clearLayers(); } else { plainStoreLayer.clearLayers(); }

  let count = 0;
  for (const s of allStores){
    if (!storePassesFilters(s)) continue;
    const mk = mkStoreMarker(s); // assumes existing helper that sets color by s.coverageType
    markerByStore.set(s.id, mk);
    if (tgCluster.checked) markers.addLayer(mk); else plainStoreLayer.addLayer(mk);
    count++;
  }
  id('inViewCount').textContent = count.toLocaleString();
}

// ---------- Fit to results (stores first, else hubs, else home) ----------
function fitToResults(){
  const group = tgCluster.checked ? markers : plainStoreLayer;
  const hasStoreMarkers = (tgCluster.checked ? group.getLayers().length : group.getLayers().length) > 0;

  if (hasStoreMarkers){
    const b = group.getBounds();
    if (b.isValid()) { map.fitBounds(b.pad(0.08)); return; }
  }
  // fallback: hubs
  const hubs = visibleHubs().map(h=>h.coords);
  if (hubs.length){
    const b = L.latLngBounds(hubs);
    if (b.isValid()){ map.fitBounds(b.pad(0.15)); return; }
  }
  // final fallback: home view
  map.setView(HOME_VIEW.center, HOME_VIEW.zoom);
}

// ---------- Rings + Overlap ----------
function updateRings(){
  ringLayer.clearLayers();
  if (!tgRings.checked) return;
  const rMeters = (Number(radius.value)||DEFAULT_RADIUS) * 1609.34;
  for (const h of visibleHubs()){
    const ring = L.circle(h.coords, { radius:rMeters, color:'#7b8794', weight:1, fillOpacity:0.05 });
    ringLayer.addLayer(ring);
  }
}

function drawOverlap(){
  // Simple overlap highlight: stores with >=2 premium hubs in range
  highlightLayer.clearLayers();
  const r = Number(radius.value)||DEFAULT_RADIUS;
  for (const s of allStores){
    const prem = (s.coverage?.hubs||[]).filter(x=>x.type==='premium' && x.dist<=r);
    if (prem.length >= 2){
      const c = L.circleMarker([s.lat, s.lng], {radius:5, color:'#b42318', weight:2, opacity:0.9});
      highlightLayer.addLayer(c);
    }
  }
}

// ---------- Sidepanel ----------
function openSidepanel(hub){
  spHub = hub;
  sidepanel.classList.add('show');
  spTitle.textContent = hub.fullName || hub.label || hub.name || 'Hub';
  renderSidepanelList();
}

function hideSidepanel(){
  sidepanel.classList.remove('show');
  spHub = null;
}

function renderSidepanelList(){
  if (!spHub){ spList.innerHTML=''; return; }
  const r = Number(radius.value)||DEFAULT_RADIUS;
  const q = (spFilter||'').trim();
  const out = [];

  for (const s of allStores){
    // must be within r of this hub
    const near = (s.coverage?.hubs||[]).some(x => x.id === spHub.id && x.dist <= r);
    if (!near) continue;
    if (!storePassesFilters(s)) continue; // respect global filters

    const line = `${s.store_name||s.name||'Store'} — ${s.city||''}, ${s.state||''} ${s.postal||s.zip||''}`.trim();
    if (q && !line.toLowerCase().includes(q.toLowerCase())) continue;

    out.push({s, line});
  }

  out.sort((a,b)=> a.line.localeCompare(b.line));

  // render
  const frag = document.createDocumentFragment();
  for (const {s, line} of out){
    const li = document.createElement('li');
    li.className = 'sp-item';
    li.innerHTML = `
      <div class="sp-line">${escapeHtml(line)}</div>
      <div class="sp-sub">
        <span class="dot" style="background:${COLORS[s.coverageType]}"></span>
        <span>${s.coverageType}</span>
      </div>`;
    li.addEventListener('click', ()=>{
      map.setView([s.lat, s.lng], Math.max(map.getZoom(), 9));
      // open popup on first click reliably
      const mk = markerByStore.get(s.id);
      if (mk){ mk.openPopup(); }
    });
    frag.appendChild(li);
  }

  spCount.textContent = out.length.toLocaleString();
  spList.innerHTML = '';
  spList.appendChild(frag);
}

// ---------- Visibility toggles ----------
function handleHubVisibilityChange(){
  // Recompute because which hub sets are active changed
  recomputeCoverage();
  renderHubs();
  updateRings();
  runFilter();
  fitToResults();
  buildHubFilterOptions();
  saveState();
  if (tgOverlap.checked) drawOverlap();
}

// ---------- Initial legend (idempotent) ----------
let _legendRendered = false;
function renderLegend(){
  if (_legendRendered) return;
  _legendRendered = true;
  const legend = id('legend');
  if (!legend) return;
  const keys = ['Premium + Acosta','Premium Only','Acosta Only','Uncovered'];
  legend.innerHTML = keys.map(k => `
    <div class="leg-row"><span class="dot" style="background:${COLORS[k]}"></span> ${k}</div>
  `).join('');
}
</script>
<script>
// =========================
// CHUNK 6 — Search, Export/Print, Debounce, Chips, State, Utils
// =========================

// ---------- Debouncers ----------
function debounce(fn, wait=150){
  let t; return (...args)=>{ clearTimeout(t); t=setTimeout(()=>fn(...args), wait); };
}
const debouncedRun          = debounce(()=>runFilter(), 120);
const debouncedFitToResults = debounce(()=>fitToResults(), 160);

// ---------- Select filter text matching ----------
function filterSelect(selectEl, q){
  const query = (q||'').trim().toLowerCase();
  let shown = 0;
  for (const opt of selectEl.options){
    if (opt.value === '') { opt.hidden = false; continue; } // keep placeholder
    const txt = opt.textContent.toLowerCase();
    const hit = !query || txt.includes(query);
    opt.hidden = !hit;
    if (hit) shown++;
  }
  // If nothing visible besides placeholder, no-op
  return shown;
}

// ---------- Chips (tiny summary of active filters) ----------
function renderChips(){
  const row = id('chips'); if (!row) return;
  const parts = [];
  const pick = (el,label)=> {
    const vals = getSelVals(el);
    if (vals.length){ parts.push(`${label}: ${vals.join(', ')}`); }
  };
  pick(covFilter,'Coverage'); pick(rmFilter,'RM'); pick(amFilter,'AM'); pick(hubFilter,'Hubs');
  if (tgWithin.checked) parts.push(`Within ${Number(radius.value)||DEFAULT_RADIUS} mi`);
  row.innerHTML = parts.length
    ? parts.map(t=>`<span class="chip">${escapeHtml(t)}</span>`).join(' ')
    : `<span class="chip chip-muted">No filters</span>`;
}

// ---------- Search index (stores by name/city/state) ----------
let SEARCH_INDEX = []; // {id, name, city, state, lat, lng, label}
const LS_LAST_QUERY = 'trainer_map_last_query';

function buildSearchIndex(){
  SEARCH_INDEX = (allStores||[]).map(s=>{
    const name = String(s.store_name||s.name||'Store');
    const city = String(s.city||'');
    const state= String(s.state||'');
    return {
      id: s.id, lat: s.lat, lng: s.lng,
      label: `${name} — ${city}, ${state}`.trim(),
      hay: `${name} ${city} ${state}`.toLowerCase()
    };
  });
}

// ---------- Search UI ----------
function hideResults(){
  const el = id('searchResults');
  if (el){ el.innerHTML = ''; el.classList.remove('show'); }
}
function showResults(items){
  const el = id('searchResults'); if (!el) return;
  el.innerHTML = items.map(it=>`<div class="result" data-id="${it.id}">${escapeHtml(it.label)}</div>`).join('');
  el.classList.add('show');
  // Click handling
  Array.from(el.querySelectorAll('.result')).forEach(div=>{
    div.addEventListener('click', ()=>{
      const sid = div.dataset.id;
      const s = allStores.find(x=>x.id===sid);
      if (!s) return;
      focusStoreOnMap(s, /*openPopup*/true);
      hideResults();
      id('searchBox').blur();
    });
  });
}

function focusStoreOnMap(s, openPopup=true){
  // Ensure the store passes current filters; if not, temporarily show it anyway by panning + popup
  // Pan first; open popup after moveend to fix the "first search" issue.
  const target = [s.lat, s.lng];
  map.once('moveend', ()=>{
    const mk = markerByStore.get(s.id) || mkStoreMarker(s);
    if (!markerByStore.has(s.id)){
      // Add temp marker if it's filtered out; add to a temp layer
      (window._tempLayer ||= L.layerGroup().addTo(map)).addLayer(mk);
    }
    if (openPopup) mk.openPopup();
  });
  map.setView(target, Math.max(map.getZoom(), 10));
  // Visual target pin
  setTargetPin(target);
}

// Search typing (instant)
(function wireSearch(){
  const box = id('searchBox'); if (!box) return;
  const badge = id('searchBadge'); const wrap = document.querySelector('.searchbox');
  box.addEventListener('input', ()=>{
    const q = box.value.trim().toLowerCase();
    if (!q){ hideResults(); clearTarget(); badge?.classList.remove('show'); wrap?.classList.remove('has-badge'); return; }
    const hits = SEARCH_INDEX.filter(x => x.hay.includes(q)).slice(0, 25);
    showResults(hits);
    if (hits.length){
      // Soft preview: pan lightly and drop target pin, no popup yet
      map.setView([hits[0].lat, hits[0].lng], Math.max(map.getZoom(), 9), {animate:false});
      setTargetPin([hits[0].lat, hits[0].lng]);
      badge?.classList.add('show'); wrap?.classList.add('has-badge');
    }
    localStorage.setItem(LS_LAST_QUERY, box.value);
  });

  // Restore last query badge
  const last = localStorage.getItem(LS_LAST_QUERY)||'';
  if (last){
    box.value = last;
    const q = last.trim().toLowerCase();
    const hits = SEARCH_INDEX.filter(x => x.hay.includes(q)).slice(0, 15);
    if (hits.length){ showResults(hits); setTargetPin([hits[0].lat, hits[0].lng]); badge?.classList.add('show'); wrap?.classList.add('has-badge'); }
  }
})();

// ---------- Target pin (single) ----------
const targetLayer = L.layerGroup().addTo(map);
let targetPin = null;
function setTargetPin(latlng){
  clearTarget();
  targetPin = L.marker(latlng, {
    icon: L.divIcon({
      className: 'target-pin',
      html: '<div style="width:18px;height:18px;border-radius:50%;background:#2f71ff;border:2px solid #fff;box-shadow:0 0 0 1px rgba(0,0,0,.25)"></div>'
    })
  }).addTo(targetLayer);
}
function clearTarget(){
  targetLayer.clearLayers();
  targetPin = null;
}

// ---------- Export stores (filtered) ----------
function exportStoresCsv(){
  const rows = [];
  rows.push(['StoreID','StoreName','City','State','ZIP','CoverageType','Lat','Lng']); // header
  for (const s of allStores){
    if (!storePassesFilters(s)) continue;
    rows.push([
      s.id,
      (s.store_name||s.name||'').replace(/,/g,' '),
      (s.city||'').replace(/,/g,' '),
      (s.state||'').replace(/,/g,' '),
      (s.postal||s.zip||''),
      s.coverageType||'',
      s.lat, s.lng
    ]);
  }
  const csv = rows.map(r => r.join(',')).join('\n');
  downloadBlob(csv, 'filtered_stores.csv', 'text/csv');
}

// ---------- Sidepanel export/print ----------
function exportSidepanelCsv(){
  if (!spHub) return;
  const r = Number(radius.value)||DEFAULT_RADIUS;
  const rows = [];
  rows.push(['StoreID','StoreName','City','State','ZIP','CoverageType','Lat','Lng','Hub']);
  for (const s of allStores){
    const near = (s.coverage?.hubs||[]).some(x => x.id === spHub.id && x.dist <= r);
    if (!near) continue;
    if (!storePassesFilters(s)) continue;
    rows.push([
      s.id,
      (s.store_name||s.name||'').replace(/,/g,' '),
      (s.city||'').replace(/,/g,' '),
      (s.state||'').replace(/,/g,' '),
      (s.postal||s.zip||''),
      s.coverageType||'',
      s.lat, s.lng,
      spHub.fullName||spHub.label||spHub.name||''
    ]);
  }
  const csv = rows.map(r => r.join(',')).join('\n');
  const clean = (spHub.fullName||spHub.label||spHub.name||'hub').replace(/[^\w\-]+/g,'_');
  downloadBlob(csv, `stores_${clean}.csv`, 'text/csv');
}

function printSidepanelList(){
  // Simple print of the currently rendered list
  const w = window.open('', '_blank');
  const title = spHub ? (spHub.fullName||spHub.label||spHub.name||'Hub') : 'Stores';
  const listHtml = spList ? spList.innerHTML : '';
  w.document.write(`
    <html><head><title>${escapeHtml(title)}</title>
      <style>
        body{ font-family:ui-sans-serif,system-ui,Arial,sans-serif; padding:24px; }
        h1{ font-size:18px; margin:0 0 12px; }
        .row{ display:flex; align-items:center; gap:8px; margin:6px 0; }
        .dot{ display:inline-block; width:10px; height:10px; border-radius:50%; margin-right:6px; vertical-align:middle; }
        .sp-item{ padding:6px 0; border-bottom:1px solid #eee; }
        .sp-line{ font-weight:600; }
        .sp-sub{ color:#555; font-size:12px; }
      </style>
    </head><body>
      <h1>${escapeHtml(title)} — ${spCount?.textContent||''} stores</h1>
      <ul style="list-style:none;padding:0;margin:0">${listHtml}</ul>
      <script>window.onload=()=>window.print();<\/script>
    </body></html>
  `);
  w.document.close();
}

// ---------- Download helper ----------
function downloadBlob(content, filename, type){
  const blob = new Blob([content], {type});
  const url  = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = filename;
  document.body.appendChild(a); a.click();
  setTimeout(()=>{ URL.revokeObjectURL(url); a.remove(); }, 0);
}

// ---------- State save/restore ----------
const LS_KEY = 'trainer_map_state_v3';

function saveState(){
  try{
    const state = {
      cov: getSelVals(covFilter),
      rm:  getSelVals(rmFilter),
      am:  getSelVals(amFilter),
      hub: getSelVals(hubFilter),
      r:   Number(radius.value)||DEFAULT_RADIUS,
      tg: {
        heat: tgHeat.checked, rings: tgRings.checked, overlap: tgOverlap.checked,
        compare: tgCompare.checked, within: tgWithin.checked, cluster: tgCluster.checked
      },
      vis: {
        confirmed: showConfirmed.checked,
        pending:   showPending.checked,
        acosta:    showAcosta.checked
      }
    };
    localStorage.setItem(LS_KEY, JSON.stringify(state));
  }catch(e){ console.warn('saveState failed', e); }
}

function tryLoadLocal(){
  try{
    const raw = localStorage.getItem(LS_KEY);
    if (!raw) return false;
    const st = JSON.parse(raw);
    // apply
    setMultiSelect(covFilter, st.cov||[]);
    setMultiSelect(rmFilter,  st.rm||[]);
    rebuildAMOptionsWithCounts();
    setMultiSelect(amFilter,  st.am||[]);
    buildHubFilterOptions();
    setMultiSelect(hubFilter, st.hub||[]);
    radius.value = st.r || DEFAULT_RADIUS; radiusLbl.textContent = radius.value;
    if (st.tg){
      tgHeat.checked = !!st.tg.heat; tgRings.checked = !!st.tg.rings; tgOverlap.checked = !!st.tg.overlap;
      tgCompare.checked = !!st.tg.compare; tgWithin.checked = !!st.tg.within; tgCluster.checked = !!st.tg.cluster;
    }
    if (st.vis){
      showConfirmed.checked = !!st.vis.confirmed;
      showPending.checked   = !!st.vis.pending;
      showAcosta.checked    = !!st.vis.acosta;
    }
    renderChips();
    return true;
  }catch(e){ console.warn('tryLoadLocal failed', e); return false; }
}

// Placeholder for snapshots if you add shareable views later
function tryLoadSnapshot(){ return false; }

function setMultiSelect(selectEl, values){
  const want = new Set(values||[]);
  for (const opt of selectEl.options){
    opt.selected = want.has(opt.value);
  }
}

// ---------- Misc utils ----------
function escapeHtml(s){ return String(s).replace(/[&<>"']/g, m=>({ '&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;' }[m])); }
function updateInViewCount(){
  const group = tgCluster.checked ? markers : plainStoreLayer;
  const n = group.getLayers().length;
  id('inViewCount').textContent = (n||0).toLocaleString();
}

// Compare panel stub (safe if UI not present)
function refreshComparePanel(){
  const el = id('comparePanel');
  if (!el) return;
  // If you have a UI, compute stats for pinnedHubs here.
  el.textContent = compareMode && (pinnedHubs||[]).length ? `${pinnedHubs.length} pinned` : '';
}
</script>
<script>
// =========================
// CHUNK 7 — Acosta Toggle Overrides, Marker Factories, Utils
// =========================

// ---------- Colors / styles ----------
const COLORS = {
  "Premium + Acosta": "#6c5ce7",
  "Premium Only":     "#2ecc71",
  "Acosta Only":      "#f39c12",
  "Uncovered":        "#e74c3c",
  hubConfirmed:       "#2563eb",
  hubPendingOffer:    "#7c3aed",
  hubProposed:        "#64748b",
  hubAcosta:          "#374151"
};

// ---------- Basic DOM / event helpers (safe to re-declare) ----------
function id(s){ return document.getElementById(s); }
function on(evt, el, cb){ el?.addEventListener(evt, cb); }

// ---------- Distance / slug utils ----------
function distMiles(lat1, lon1, lat2, lon2){
  const toRad = x => x * Math.PI/180;
  const R = 3958.761; // mi
  const dLat = toRad(lat2-lat1), dLon = toRad(lon2-lon1);
  const a = Math.sin(dLat/2)**2 + Math.cos(toRad(lat1))*Math.cos(toRad(lat2))*Math.sin(dLon/2)**2;
  return 2*R*Math.asin(Math.sqrt(a));
}
function slug(s){ return String(s||'').toLowerCase().replace(/[^a-z0-9]+/g,'-').replace(/(^-|-$)/g,''); }

// ---------- Coverage counts helper (used by cluster tooltips) ----------
function coverageCounts(layersOrMarkers){
  const out = {"Premium + Acosta":0,"Premium Only":0,"Acosta Only":0,"Uncovered":0};
  const list = Array.isArray(layersOrMarkers) ? layersOrMarkers : [];
  for (const m of list){
    const s = m._store || m.store || null;
    const k = s?.coverageType || 'Uncovered';
    if (out[k] == null) out[k] = 0;
    out[k]++;
  }
  return out;
}

// ---------- Marker factories ----------
function storeColorFor(s){
  return COLORS[s.coverageType] || COLORS["Uncovered"];
}

function mkStoreMarker(s){
  // circle marker + popup; attach backref for cluster summaries
  const mk = L.circleMarker([s.lat, s.lng], {
    radius: 5,
    color: storeColorFor(s),
    weight: 1,
    fillOpacity: 0.9
  });
  mk._store = s;
  mk.bindPopup(storePopupHtml(s), { maxWidth: 360, autoPan:true });
  return mk;
}

function statusToColor(h){
  if (h.status === 'acosta') return COLORS.hubAcosta;
  if (h.statusSub === 'pending_offer') return COLORS.hubPendingOffer;
  if (h.status === 'confirmed') return COLORS.hubConfirmed;
  return COLORS.hubProposed; // proposed/open/pending_candidate
}

function mkHubMarker(h){
  const color = statusToColor(h);
  const html = `
    <div style="
      display:flex;align-items:center;justify-content:center;
      width:22px;height:22px;border-radius:50%;
      background:${color};border:2px solid #fff;box-shadow:0 0 0 1px rgba(0,0,0,.25)
    "></div>`;
  const icon = L.divIcon({ className:'hub-pin', html, iconSize:[22,22], iconAnchor:[11,11] });
  const m = L.marker(h.coords, { icon });
  m.bindTooltip(escapeHtml(h.fullName || h.label || h.name || 'Hub'), { direction:'top', offset:[0,-10], opacity:0.95, sticky:true });
  m._hub = h;
  return m;
}

// ---------- Store popup ----------
function storePopupHtml(s){
  const name  = escapeHtml(s.store_name || s.name || 'Store');
  const city  = escapeHtml(s.city||'');
  const state = escapeHtml(s.state||'');
  const zip   = escapeHtml(s.postal || s.zip || '');
  const cov   = escapeHtml(s.coverageType || 'Uncovered');

  // List hubs within radius with distance
  const r = Number(radius.value)||DEFAULT_RADIUS;
  const near = (s.coverage?.hubs||[]).filter(x => x.dist <= r);
  const hubLines = near.length
    ? near.slice(0, 6).map(x=>{
        const h = (premiumConfirmed||[]).concat(premiumPending||[]).concat(acostaHubs||[]).find(hh=>hh.id===x.id);
        const lbl = h ? (h.fullName||h.label||h.name) : x.id;
        return `<div class="hub-line">
          <span style="display:inline-block;width:8px;height:8px;border-radius:50%;background:${x.type==='acosta'?COLORS.hubAcosta:COLORS.hubConfirmed};margin-right:6px"></span>
          ${escapeHtml(lbl)} — ${x.dist.toFixed(1)} mi
        </div>`;
      }).join('')
    : '<div class="hub-line muted">No hubs within radius</div>';

  return `
    <div class="pop">
      <div class="pop-title">${name}</div>
      <div class="pop-sub">${city}, ${state} ${zip}</div>
      <div class="pop-row"><span class="dot" style="background:${storeColorFor(s)}"></span> ${cov}</div>
      <div class="pop-hubs">
        <div class="pop-hdr">Nearby hubs (≤ ${r} mi)</div>
        ${hubLines}
      </div>
    </div>
  `;
}

// ---------- RM/AM populators (called during data load) ----------
function populateRM(stores){
  const mapRM = new Map();
  for (const s of stores){
    const k = String(s.rm||'').trim();
    if (!k) continue;
    mapRM.set(k, (mapRM.get(k)||0)+1);
  }
  const rows = Array.from(mapRM.entries()).sort((a,b)=> a[0].localeCompare(b[0]))
    .map(([value,count])=>({ value, label:value, count }));
  setOptions(rmFilter, rows, {placeholder:'All Regional Managers', keepSelection:false});
}
function populateAM(stores){
  // Initial (unconstrained) list; it will be rebuilt by rebuildAMOptionsWithCounts()
  const mapAM = new Map();
  for (const s of stores){
    const k = String(s.am||'').trim();
    if (!k) continue;
    mapAM.set(k, (mapAM.get(k)||0)+1);
  }
  const rows = Array.from(mapAM.entries()).sort((a,b)=> a[0].localeCompare(b[0]))
    .map(([value,count])=>({ value, label:value, count }));
  setOptions(amFilter, rows, {placeholder:'All Area Managers', keepSelection:false});
}

// ---------- Hub selection pruning when visibility set changes ----------
function pruneHubSelections(){
  const visible = new Set(visibleHubs().map(h=>h.id));
  const before = new Set(getSelVals(hubFilter));
  if (!before.size) return;
  const keep = Array.from(before).filter(id => visible.has(id));
  if (keep.length !== before.size){
    setMultiSelect(hubFilter, keep);
  }
}

// ---------- Override: visibility handler with pruning (replaces earlier) ----------
function handleHubVisibilityChange(){
  // Recompute/refresh since hub sets changed (Acosta, Pending, Confirmed)
  recomputeCoverage();
  renderHubs();
  updateRings();

  // Rebuild hub options & prune any selections that are no longer visible
  buildHubFilterOptions();
  pruneHubSelections();

  runFilter();
  fitToResults();
  saveState();

  if (tgOverlap.checked) drawOverlap();
  renderChips();
}

// Ensure Acosta toggle starts as OFF by default (if desired) without clobbering saved state
(function ensureAcostaDefault(){
  try{
    const raw = localStorage.getItem('trainer_map_state_v3');
    if (!raw){ // only enforce default if no prior state exists
      showAcosta.checked = false;
    }
  }catch(e){}
})();
</script>
<script>
// =========================
// CHUNK 8 — Init glue
// =========================

// Once everything loaded in Chunk 4–7, these calls are idempotent
// They ensure map + layers are drawn and filters work.

function initMapApp(){
  try{
    recomputeCoverage();
    renderHubs();
    refreshLayerMode();
    runFilter();
    fitToResults();
    updateRings();
    renderLegend();
    renderChips();
    updateInViewCount();
    saveState();
    console.log("Trainer Map initialized successfully.");
  }catch(e){
    console.error("InitMapApp error:", e);
  }
}

// Run after window load
window.addEventListener('load', ()=>{
  initMapApp();
});
</script>
</body>
</html>
